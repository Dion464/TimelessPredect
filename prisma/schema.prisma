// Prisma schema matched with the functions we call in the chain  

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Trade {
  id          BigInt   @id @default(autoincrement()) @map("id")
  txHash      String   @map("tx_hash")
  logIndex    Int      @map("log_index")
  marketId    BigInt   @map("market_id")
  trader      String   @map("trader")
  isYes       Boolean  @map("is_yes")
  sharesWei   String   @map("shares_wei")
  priceBps    Int      @map("price_bps")
  costWei     String   @map("cost_wei")
  tradeType   String?  @map("trade_type")
  blockNumber BigInt   @map("block_number")
  blockTime   DateTime @map("block_time")

  @@unique([txHash, logIndex])
  @@index([marketId, blockNumber], map: "trades_market_idx")
  @@index([trader], map: "trades_trader_idx")
  @@map("trades")
}

model Market {
  marketId          BigInt    @id @map("market_id")
  question          String?   @map("question")
  description       String?   @map("description")
  category          String?   @map("category")
  imageUrl          String?   @map("image_url")
  endTime           DateTime? @map("end_time")
  resolutionTime    DateTime? @map("resolution_time")
  resolved          Boolean   @default(false) @map("resolved")
  outcome           Int?      @map("outcome")
  totalYesSharesWei String    @default("0") @map("total_yes_shares_wei")
  totalNoSharesWei  String    @default("0") @map("total_no_shares_wei")
  totalVolumeWei    String    @default("0") @map("total_volume_wei")
  creator           String?   @map("creator")
  lastYesPriceBps   Int?      @map("last_yes_price_bps")
  lastNoPriceBps    Int?      @map("last_no_price_bps")
  lastTradeBlock    BigInt?   @map("last_trade_block_number")
  lastTradeTxHash   String?   @map("last_trade_tx_hash")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  activityEvents    ActivityEvent[]

  @@map("markets")
}

model Position {
  userAddress      String   @map("user_address")
  marketId         BigInt   @map("market_id")
  yesSharesWei     String   @default("0") @map("yes_shares_wei")
  noSharesWei      String   @default("0") @map("no_shares_wei")
  totalInvestedWei String   @default("0") @map("total_invested_wei")
  updatedAt        DateTime @default(now()) @map("updated_at")

  @@id([userAddress, marketId])
  @@map("positions")
}

enum OrderStatus {
  OPEN
  PARTIAL
  FILLED
  CANCELLED
}

model Order {
  id           BigInt      @id @default(autoincrement()) @map("id")
  maker        String      @map("maker")
  marketId     BigInt      @map("market_id")
  outcomeId    Int         @map("outcome_id")
  priceTicks   Int         @map("price_ticks")
  sizeWei      String      @map("size_wei")
  remainingWei String      @map("remaining_wei")
  side         Boolean     @map("is_buy")
  status       OrderStatus @default(OPEN) @map("status")
  signature    String      @map("signature")
  salt         String?     @map("salt")
  expiry       DateTime?   @map("expiry")
  orderHash    String?     @map("order_hash")
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")

  fillsAsMaker OrderFill[] @relation("makerFills")
  fillsAsTaker OrderFill[] @relation("takerFills")

  @@unique([signature], map: "orders_signature_unique")
  @@index([marketId, outcomeId, side, priceTicks], map: "orders_match_idx")
  @@index([maker, marketId], map: "orders_user_market_idx")
  @@map("orders")
}

model OrderFill {
  id             BigInt   @id @default(autoincrement()) @map("id")
  makerOrderId   BigInt   @map("maker_order_id")
  takerOrderId   BigInt?  @map("taker_order_id")
  marketId       BigInt   @map("market_id")
  outcomeId      Int      @map("outcome_id")
  fillSizeWei    String   @map("fill_size_wei")
  fillPriceTicks Int      @map("fill_price_ticks")
  createdAt      DateTime @default(now()) @map("created_at")

  makerOrder Order  @relation("makerFills", fields: [makerOrderId], references: [id], onDelete: Cascade)
  takerOrder Order? @relation("takerFills", fields: [takerOrderId], references: [id], onDelete: Cascade)

  @@index([marketId, outcomeId], map: "order_fills_market_idx")
  @@map("order_fills")
}

enum PendingMarketStatus {
  PENDING
  APPROVED
  REJECTED
}

model PendingMarket {
  id              BigInt              @id @default(autoincrement()) @map("id")
  question        String              @map("question")
  description     String?             @map("description")
  category        String              @map("category")
  imageUrl        String?             @map("image_url")
  endTime         DateTime            @map("end_time")
  resolutionTime  DateTime            @map("resolution_time")
  rules           String?             @map("rules") // JSON string of rules array
  creator         String              @map("creator")
  status          PendingMarketStatus @default(PENDING) @map("status")
  rejectionReason String?             @map("rejection_reason")
  approvedBy      String?             @map("approved_by")
  marketId        BigInt?             @map("market_id") // Set when approved and created on-chain
  feeTxHash       String?             @map("fee_tx_hash")
  feeAmountWei    String?             @map("fee_amount_wei")
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@index([creator, status], map: "pending_markets_creator_idx")
  @@index([status], map: "pending_markets_status_idx")
  @@map("pending_markets")
}

enum NotificationType {
  MARKET_APPROVED
  MARKET_REJECTED
  MARKET_RESOLVED
  WINNINGS_CLAIMABLE
}

model Notification {
  id              BigInt           @id @default(autoincrement()) @map("id")
  recipient       String           @map("recipient") // Wallet address
  type            NotificationType @map("type")
  title           String           @map("title")
  message         String           @map("message")
  marketId        BigInt?          @map("market_id")
  pendingMarketId BigInt?          @map("pending_market_id")
  read            Boolean          @default(false) @map("read")
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  @@index([recipient, read], map: "notifications_recipient_idx")
  @@index([recipient, createdAt], map: "notifications_recipient_created_idx")
  @@map("notifications")
}

enum ActivityEventType {
  MARKET_CREATED
  ORDER_PLACED
  ORDER_FILLED
  POSITION_UPDATED
  MARKET_RESOLVED
  LIQUIDITY_ADDED
  LIQUIDITY_REMOVED
}

model ActivityEvent {
  id          BigInt            @id @default(autoincrement()) @map("id")
  marketId    BigInt            @map("market_id")
  userAddress String?           @map("user_address")
  eventType   ActivityEventType @map("event_type")
  txHash      String?           @map("tx_hash")
  blockNumber BigInt?           @map("block_number")
  blockTime   DateTime?         @map("block_time")
  description String?           @map("description")
  metadata    Json?             @map("metadata")
  createdAt   DateTime          @default(now()) @map("created_at")

  market Market @relation(fields: [marketId], references: [marketId])

  @@index([marketId, createdAt], map: "activity_events_market_created_idx")
  @@index([userAddress, createdAt], map: "activity_events_user_created_idx")
  @@map("activity_events")
}

model PriceSnapshot {
  id          BigInt   @id @default(autoincrement()) @map("id")
  marketId    BigInt   @map("market_id")
  yesPriceBps Int      @map("yes_price_bps") // Price in basis points (5000 = 50%)
  noPriceBps  Int      @map("no_price_bps") // Price in basis points (5000 = 50%)
  blockNumber BigInt?  @map("block_number")
  timestamp   DateTime @default(now()) @map("timestamp")

  @@index([marketId, timestamp], map: "price_snapshots_market_timestamp_idx")
  @@map("price_snapshots")
}
